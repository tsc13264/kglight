from . import RLAgent
from common.registry import Registry
from agent import utils
import numpy as np
import os
import random
from collections import deque
import gym
import json

from generator import LaneVehicleGenerator, IntersectionPhaseGenerator, IntersectionVehicleGenerator

import torch
from torch import nn
import torch.nn.functional as F
import torch.optim as optim
from torch.nn.utils import clip_grad_norm_

from torch.utils.tensorboard import SummaryWriter


@Registry.register_model('kglight')
class KGLightAgent(RLAgent):
    def __init__(self, world, rank):
        super().__init__(world, rank)
        self.gamma = Registry.mapping['model_mapping']['setting'].param['gamma']
        self.grad_clip = Registry.mapping['model_mapping']['setting'].param['grad_clip']
        self.epsilon = Registry.mapping['model_mapping']['setting'].param['epsilon']
        self.epsilon_decay = Registry.mapping['model_mapping']['setting'].param['epsilon_decay']
        self.epsilon_min = Registry.mapping['model_mapping']['setting'].param['epsilon_min']
        self.learning_rate = Registry.mapping['model_mapping']['setting'].param['learning_rate']
        self.vehicle_max = Registry.mapping['model_mapping']['setting'].param['vehicle_max']
        self.batch_size = Registry.mapping['model_mapping']['setting'].param['batch_size']
        self.poi_data_path = os.path.join(Registry.mapping['logger_mapping']['setting'].param['poi_dir'],
                                          Registry.mapping['world_mapping']['setting'].param['network'],
                                          Registry.mapping['world_mapping']['setting'].param['network']+"_light_anglestat.json")
        
        self.model_dict = Registry.mapping['model_mapping']['setting'].param
        self.model_dict['phase_length'] = self.phase_length
        self.tensor_poi_data()
        
        self.model = self._build_model()
        self.target_model = self._build_model()
        self.update_target_network()
        self.criterion = nn.MSELoss(reduction='mean')
        self.optimizer = optim.RMSprop(self.model.parameters(),
                                       lr=self.learning_rate,
                                       alpha=0.9, centered=False, eps=1e-7)
        
    def tensor_poi_data(self):
        with open(self.poi_data_path, 'r') as f:
            poi_data = json.load(f)
        if not poi_data.get(f'{self.rank}'):
            self.poi_tns = torch.zeros(8, 8, device=self.device)
        else:
            cur_poi_data = poi_data[f'{self.rank}']
            poi_arr = np.array([value for value in cur_poi_data.values()])
            if not poi_arr.size > 0:
                self.poi_tns = torch.zeros(8, 8, device=self.device)
            else:
                self.poi_tns = torch.tensor(poi_arr, dtype=torch.float32, device=self.device)
        
        try:
            self.model_dict['angle_dim'] = self.poi_tns.shape[0]
            self.model_dict['poi_dim'] = self.poi_tns.shape[1]
        except:
            print(self.rank)
        
    def __repr__(self):
        return self.model.__repr__()

    def get_ob(self):
        '''
        get_ob
        Get observation from environment.

        :param: None
        :return x_obs: observation generated by ob_generator
        '''
        if self.rank == 213:
            a = 1
        x_obs = []
        x_obs.append(self.ob_generator.generate())
        x_obs = np.array(x_obs, dtype=np.float32)
        # x_obs = np.clip(x_obs, a_min=None, a_max=10)
        return x_obs

    def get_reward(self):
        '''
        get_reward
        Get reward from environment.

        :param: None
        :return rewards: rewards generated by reward_generator
        '''
        rewards = []
        rewards.append(self.reward_generator.generate())
        rewards = np.squeeze(np.array(rewards)) * 12
        return rewards

    def get_phase(self):
        '''
        get_phase
        Get current phase of intersection(s) from environment.

        :param: None
        :return phase: current phase generated by phase_generator
        '''
        phase = []
        phase.append(self.phase_generator.generate())
        # phase = np.concatenate(phase, dtype=np.int8)
        phase = (np.concatenate(phase)).astype(np.int8)
        return phase

    def get_action(self, ob, phase, test=False):
        '''
        get_action
        Generate action.

        :param ob: observation
        :param phase: current phase
        :param test: boolean, decide whether is test process
        :return action: action that has the highest score
        '''
        if not test:
            if np.random.rand() <= self.epsilon:
                return self.sample()
        if self.phase:
            if self.one_hot:
                feature = np.concatenate([ob, utils.idx2onehot(phase, self.action_space.n)], axis=1)
            else:
                feature = np.concatenate([ob, phase], axis=1)
        else:
            feature = ob
        observation = torch.tensor(feature, dtype=torch.float32, device=self.device)
        # TODO: no need to calculate gradient when interacting with environment
        poi = self.poi_tns.unsqueeze(0)
        actions = self.model(observation, poi, train=False)
        actions = actions.cpu().clone().detach().numpy()
        return np.argmax(actions, axis=1)

    def sample(self):
        '''
        sample
        Sample action randomly.

        :param: None
        :return: action generated randomly.
        '''
        return np.random.randint(0, self.action_space.n, self.sub_agents)

    def _build_model(self):
        '''
        _build_model
        Build a DQN model.

        :param: None
        :return model: DQN model
        '''
        model = KGLightNet(self.ob_length, self.action_space.n, **self.model_dict).to(self.device)
        return model

    def remember(self, last_obs, last_phase, actions, actions_prob, rewards, obs, cur_phase, done, key):
        '''
        remember
        Put current step information into replay buffer for training agent later.

        :param last_obs: last step observation
        :param last_phase: last step phase
        :param actions: actions executed by intersections
        :param actions_prob: the probability that the intersections execute the actions
        :param rewards: current step rewards
        :param obs: current step observation
        :param cur_phase: current step phase
        :param done: boolean, decide whether the process is done
        :param key: key to store this record, e.g., episode_step_agentid
        :return: None
        '''
        if self.rank == 213:
            a = 1
        self.replay_buffer.append((key, (last_obs, last_phase, actions, rewards, obs, cur_phase)))

    def _batchwise(self, samples):
        '''
        _batchwise
        Reconstruct the samples into batch form(last state, current state, reward, action).

        :param samples: original samples record in replay buffer
        :return state_t, state_tp, rewards, actions: information with batch form
        '''
        obs_t = np.concatenate([item[1][0] for item in samples])
        obs_tp = np.concatenate([item[1][4] for item in samples])
        if self.phase:
            if self.one_hot:
                phase_t = np.concatenate([utils.idx2onehot(item[1][1], self.action_space.n) for item in samples])
                phase_tp = np.concatenate([utils.idx2onehot(item[1][5], self.action_space.n) for item in samples])
            else:
                phase_t = np.concatenate([item[1][1] for item in samples])
                phase_tp = np.concatenate([item[1][5] for item in samples])
            feature_t = np.concatenate([obs_t, phase_t], axis=1)
            feature_tp = np.concatenate([obs_tp, phase_tp], axis=1)
        else:
            feature_t = obs_t
            feature_tp = obs_tp
        state_t = torch.tensor(feature_t, dtype=torch.float32, device=self.device)
        state_tp = torch.tensor(feature_tp, dtype=torch.float32, device=self.device)
        rewards = torch.tensor(np.array([item[1][3] for item in samples]), dtype=torch.float32, device=self.device)
        actions = torch.tensor(np.array([item[1][2] for item in samples]), dtype=torch.long, device=self.device)
        return state_t, state_tp, rewards, actions

    def train(self):
        '''
        train
        Train the agent, optimize the action generated by agent.

        :param: None
        :return: value of loss
        '''
        samples = random.sample(self.replay_buffer, self.batch_size)
        poi = self.poi_tns.unsqueeze(0).repeat(self.batch_size, 1, 1)
        b_t, b_tp, rewards, actions = self._batchwise(samples)
        out = self.target_model(b_tp, poi, train=False)
        target = rewards + self.gamma * torch.max(out, dim=1)[0]
        target_f = self.model(b_t, poi, train=False)
        for i, action in enumerate(actions):
            target_f[i][action] = target[i]
        loss = self.criterion(self.model(b_t, poi, train=True), target_f)
        self.optimizer.zero_grad()
        loss.backward()
        clip_grad_norm_(self.model.parameters(), self.grad_clip)
        self.optimizer.step()
        if self.epsilon > self.epsilon_min:
            self.epsilon *= self.epsilon_decay
        return loss.cpu().detach().numpy()

    def update_target_network(self):
        '''
        update_target_network
        Update params of target network.

        :param: None
        :return: None
        '''
        weights = self.model.state_dict()
        self.target_model.load_state_dict(weights)

    def load_model(self, e):
        '''
        load_model
        Load model params of an episode.

        :param e: specified episode
        :return: None
        '''
        model_name = os.path.join(Registry.mapping['logger_mapping']['path'].path,
                                  'model', f'{e}_{self.rank}.pt')
        self.model = self._build_model()
        self.model.load_state_dict(torch.load(model_name))
        self.target_model = self._build_model()
        self.target_model.load_state_dict(torch.load(model_name))

    def save_model(self, e):
        '''
        save_model
        Save model params of an episode.

        :param e: specified episode, used for file name
        :return: None
        '''
        path = os.path.join(Registry.mapping['logger_mapping']['path'].path, 'model')
        if not os.path.exists(path):
            os.makedirs(path)
        model_name = os.path.join(path, f'{e}_{self.rank}.pt')
        torch.save(self.target_model.state_dict(), model_name)


class Attention(nn.Module):
    def __init__(self, embedding_dim, n_heads=1, dropout=0.1):
        super(Attention, self).__init__()
        self.embedding_dim = embedding_dim
        self.n_heads = n_heads
        self.dropout = dropout
        self.query_linear = nn.Linear(embedding_dim, embedding_dim)
        self.key_linear = nn.Linear(embedding_dim, embedding_dim)
        self.value_linear = nn.Linear(embedding_dim, embedding_dim)
        self.out_linear = nn.Linear(embedding_dim, embedding_dim)
        self.dropout_layer = nn.Dropout(dropout)
        
    def forward(self, x):
        query = self.query_linear(x)
        key = self.key_linear(x)
        value = self.value_linear(x)
        attention_scores = torch.matmul(query, key.transpose(-2, -1)) / torch.sqrt(torch.tensor(self.embedding_dim, dtype=torch.float32))  # (batch_size, seq_len, seq_len)
        attention_weights = F.softmax(attention_scores, dim=-1)
        attention_weights = self.dropout_layer(attention_weights)
        attention_output = torch.matmul(attention_weights, value)
        return attention_output

class KGLightNet(nn.Module):
    def __init__(self, input_dim, output_dim, **kwargs):
        super(KGLightNet, self).__init__()
        self.attention_layer = Attention(kwargs['poi_dim'])
        self.phase_length = kwargs['phase_length']
        self.ob_length = input_dim - self.phase_length
        
        self.linear_1 = nn.Linear(kwargs['angle_dim']*kwargs['poi_dim'], self.ob_length)
        self.dense_1 = nn.Linear(input_dim, 20)
        self.dense_2 = nn.Linear(20, 20)
        self.dense_3 = nn.Linear(20, output_dim)

    def _forward(self, x, poi):
        poi = self.attention_layer(poi)
        poi_w = F.softmax(self.linear_1(poi.view(poi.size(0), -1)), dim=-1)
        # x = torch.cat((x, poi_w * x[:, :self.ob_length]), dim=1)
        x = torch.cat((x[:, self.ob_length:self.ob_length+self.phase_length], poi_w * x[:, :self.ob_length]), dim=1)
        x = F.relu(self.dense_1(x))
        x = F.relu(self.dense_2(x))
        x = self.dense_3(x)
        return x

    def forward(self, x, poi, train=True):
        if train:
            return self._forward(x, poi)
        else:
            with torch.no_grad():
                return self._forward(x, poi)
